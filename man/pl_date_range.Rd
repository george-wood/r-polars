% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions__eager.R
\name{pl_date_range}
\alias{pl_date_range}
\title{New date range}
\usage{
pl_date_range(
  start,
  end,
  interval,
  closed = "both",
  time_unit = "us",
  time_zone = NULL,
  explode = TRUE,
  eager = FALSE
)
}
\arguments{
\item{start}{Lower bound of the date range. POSIXt or Date preferably with
time_zone or double or integer}

\item{end}{Upper bound of the date range. POSIXt or Date preferably with
time_zone or double or integer. If \code{end} and \code{interval} are missing, then a
single datetime is constructed.}

\item{interval}{String, a Polars \code{duration} or R \code{\link[=difftime]{difftime()}}. Can be missing
if \code{end} is missing also.}

\item{closed}{Define which sides of the range are closed (inclusive). One of
\code{"both"} (default), \code{"left"}, \code{"none"} or \code{"right"}.}

\item{time_unit}{String (\code{"ns"}, \code{"us"}, \code{"ms"}) or integer. Time unit of the
resulting \code{Datetime} data type. Only takes effect if the output column is
of type \code{Datetime}.}

\item{time_zone}{Time zone of the resulting \code{Datetime} data type. Only takes
effect if the output column is of type \code{Datetime.} If \code{NULL} (default),
\verb{"GMT} is used.}

\item{explode}{Deprecated.}

\item{eager}{If \code{FALSE} (default), returns an \code{Expr}. Otherwise, returns a
\code{Series}.}
}
\value{
A datetime or date Expr (if \code{eager = FALSE}) or Series (if \code{eager = TRUE})
}
\description{
This generate a date range from a lower and an upper bound. This only
accepts one value for each bound. Use \code{\link[=pl_date_ranges]{pl$date_ranges()}} to
generate a date range using other columns of a Data/LazyFrame as
bounds.
}
\details{
If param \code{time_zone} is not defined the Series will have no time
zone.

Note that R POSIXt without defined timezones (tzone/tz), so-called naive
datetimes, are counter intuitive in R. It is recommended to always set the
timezone of start and end. If not output will vary between local machine
timezone, R and polars.

In R/r-polars it is perfectly fine to mix timezones of params \code{time_zone},
\code{start} and \code{end}.
}
\examples{
# All in GMT, straight forward, no mental confusion
s_gmt = pl$date_range(
  as.POSIXct("2022-01-01", tz = "GMT"),
  as.POSIXct("2022-01-02", tz = "GMT"),
  interval = "6h", time_unit = "ms", time_zone = "GMT"
)
s_gmt
s_gmt$to_r()

# polars uses "GMT" if time_zone = NULL
s_null = pl$date_range(
  as.POSIXct("2022-01-01", tz = "GMT"),
  as.POSIXct("2022-01-02", tz = "GMT"),
  interval = "6h", time_unit = "ms", time_zone = NULL
)
# back to R POSIXct. R prints non tzone tagged POSIXct in local timezone
s_null$to_r()

# use of ISOdate
t1 = ISOdate(2022, 1, 1, 0) # preset GMT
t2 = ISOdate(2022, 1, 2, 0) # preset GMT
pl$date_range(t1, t2, interval = "4h", time_unit = "ms", time_zone = "GMT")$to_r()

}
